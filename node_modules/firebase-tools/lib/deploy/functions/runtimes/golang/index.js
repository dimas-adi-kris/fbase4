"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Delegate = exports.parseModule = exports.tryCreateDelegate = exports.FUNCTIONS_SDK = exports.ADMIN_SDK = void 0;
const util_1 = require("util");
const path = require("path");
const fs = require("fs");
const spawn = require("cross-spawn");
const error_1 = require("../../../../error");
const logger_1 = require("../../../../logger");
const getProjectId = require("../../../../getProjectId");
exports.ADMIN_SDK = "firebase.google.com/go/v4";
exports.FUNCTIONS_SDK = "github.com/FirebaseExtended/firebase-functions-go";
const VERSION_TO_RUNTIME = {
    "1.13": "go113",
};
async function tryCreateDelegate(context, options) {
    const relativeSourceDir = options.config.get("functions.source");
    const sourceDir = options.config.path(relativeSourceDir);
    const goModPath = path.join(sourceDir, "go.mod");
    const projectId = getProjectId(options);
    let module;
    try {
        const modBuffer = await util_1.promisify(fs.readFile)(goModPath);
        module = parseModule(modBuffer.toString("utf8"));
    }
    catch (err) {
        logger_1.logger.debug("Customer code is not Golang code (or they aren't using modules)");
        return;
    }
    let runtime = options.config.get("functions.runtime");
    if (!runtime) {
        if (!module.version) {
            throw new error_1.FirebaseError("Could not detect Golang version from go.mod");
        }
        if (!VERSION_TO_RUNTIME[module.version]) {
            throw new error_1.FirebaseError(`go.mod specifies Golang version ${module.version} which is unsupported by Google Cloud Functions. Valid values are ${Object.keys(VERSION_TO_RUNTIME).join(", ")}`);
        }
        runtime = VERSION_TO_RUNTIME[module.version];
    }
    return new Delegate(projectId, sourceDir, runtime, module);
}
exports.tryCreateDelegate = tryCreateDelegate;
function parseModule(mod) {
    const module = {
        module: "",
        version: "",
        dependencies: {},
    };
    const lines = mod.split("\n");
    let inRequire = false;
    for (const line of lines) {
        if (inRequire) {
            const endRequireMatch = /\)/.exec(line);
            if (endRequireMatch) {
                inRequire = false;
                continue;
            }
            const requireMatch = /([^ ]+) (.*)/.exec(line);
            if (requireMatch) {
                module.dependencies[requireMatch[1]] = requireMatch[2];
                continue;
            }
            if (line.trim()) {
                logger_1.logger.debug("Don't know how to handle line", line, "inside a mod.go require block");
            }
            continue;
        }
        const modMatch = /^module (.*)$/.exec(line);
        if (modMatch) {
            module.module = modMatch[1];
            continue;
        }
        const versionMatch = /^go (\d+\.\d+)$/.exec(line);
        if (versionMatch) {
            module.version = versionMatch[1];
            continue;
        }
        const requireMatch = /^require ([^ ]+) (.*)$/.exec(line);
        if (requireMatch) {
            module.dependencies[requireMatch[1]] = requireMatch[2];
            continue;
        }
        const requireBlockMatch = /^require +\(/.exec(line);
        if (requireBlockMatch) {
            inRequire = true;
            continue;
        }
        if (line.trim()) {
            logger_1.logger.debug("Don't know how to handle line", line, "in mod.go");
        }
    }
    if (!module.module) {
        throw new error_1.FirebaseError("Module has no name");
    }
    if (!module.version) {
        throw new error_1.FirebaseError(`Module ${module.module} has no go version`);
    }
    return module;
}
exports.parseModule = parseModule;
class Delegate {
    constructor(projectId, sourceDir, runtime, module) {
        this.projectId = projectId;
        this.sourceDir = sourceDir;
        this.runtime = runtime;
        this.module = module;
        this.name = "golang";
    }
    validate() {
        throw new error_1.FirebaseError("Cannot yet analyze Go source code");
    }
    build() {
        const res = spawn.sync("go", ["build"], {
            cwd: this.sourceDir,
            stdio: "inherit",
        });
        if (res.error) {
            logger_1.logger.debug("Got error running go build", res);
            throw new error_1.FirebaseError("Failed to build functions source", { children: [res.error] });
        }
        return Promise.resolve();
    }
    watch() {
        return Promise.resolve(() => Promise.resolve());
    }
    discoverSpec(configValues, envs) {
        throw new error_1.FirebaseError("Cannot yet discover function specs");
    }
}
exports.Delegate = Delegate;
