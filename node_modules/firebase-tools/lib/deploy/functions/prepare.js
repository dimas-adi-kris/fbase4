"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepare = void 0;
const clc = require("cli-color");
const ensureCloudBuildEnabled_1 = require("./ensureCloudBuildEnabled");
const functionsDeployHelper_1 = require("./functionsDeployHelper");
const utils_1 = require("../../utils");
const prepareFunctionsUpload_1 = require("./prepareFunctionsUpload");
const prompts_1 = require("./prompts");
const backend = require("./backend");
const ensureApiEnabled = require("../../ensureApiEnabled");
const functionsConfig = require("../../functionsConfig");
const getProjectId = require("../../getProjectId");
const runtimes = require("./runtimes");
const validate = require("./validate");
const utils = require("../../utils");
const logger_1 = require("../../logger");
async function prepare(context, options, payload) {
    if (!options.config.src.functions) {
        return;
    }
    const runtimeDelegate = await runtimes.getRuntimeDelegate(context, options);
    logger_1.logger.debug(`Validating ${runtimeDelegate.name} source`);
    await runtimeDelegate.validate();
    logger_1.logger.debug(`Building ${runtimeDelegate.name} source`);
    await runtimeDelegate.build();
    const projectId = getProjectId(options);
    const checkAPIsEnabled = await Promise.all([
        ensureApiEnabled.ensure(projectId, "cloudfunctions.googleapis.com", "functions"),
        ensureApiEnabled.check(projectId, "runtimeconfig.googleapis.com", "runtimeconfig", true),
        ensureCloudBuildEnabled_1.ensureCloudBuildEnabled(projectId),
    ]);
    context.runtimeConfigEnabled = checkAPIsEnabled[1];
    const firebaseConfig = await functionsConfig.getFirebaseConfig(options);
    context.firebaseConfig = firebaseConfig;
    const runtimeConfig = await prepareFunctionsUpload_1.getFunctionsConfig(context);
    const env = await prepareFunctionsUpload_1.getEnvs(context);
    logger_1.logger.debug(`Analyzing ${runtimeDelegate.name} backend spec`);
    const wantBackend = await runtimeDelegate.discoverSpec(runtimeConfig, env);
    payload.functions = { backend: wantBackend };
    if (backend.isEmptyBackend(wantBackend)) {
        return;
    }
    utils.assertDefined(options.config.src.functions.source, "Error: 'functions.source' is not defined");
    utils_1.logBullet(clc.cyan.bold("functions:") +
        " preparing " +
        clc.bold(options.config.src.functions.source) +
        " directory for uploading...");
    context.functionsSource = await prepareFunctionsUpload_1.prepareFunctionsUpload(runtimeConfig, options);
    wantBackend.cloudFunctions.forEach((fn) => {
        fn.environmentVariables = wantBackend.environmentVariables;
    });
    await Promise.all(Object.keys(wantBackend.requiredAPIs).map((friendlyName) => {
        ensureApiEnabled.ensure(projectId, wantBackend.requiredAPIs[friendlyName], friendlyName, false);
    }));
    validate.functionIdsAreValid(wantBackend.cloudFunctions);
    context.filters = functionsDeployHelper_1.getFilterGroups(options);
    const wantFunctions = wantBackend.cloudFunctions.filter((fn) => {
        return functionsDeployHelper_1.functionMatchesAnyGroup(fn, context.filters);
    });
    const haveFunctions = (await backend.existingBackend(context)).cloudFunctions;
    await prompts_1.promptForFailurePolicies(options, wantFunctions, haveFunctions);
    await prompts_1.promptForMinInstances(options, wantFunctions, haveFunctions);
    await backend.checkAvailability(context, wantBackend);
}
exports.prepare = prepare;
