"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createDeploymentPlan = exports.calculateRegionalFunctionChanges = exports.allRegions = exports.functionsByRegion = void 0;
const functionsDeployHelper_1 = require("./functionsDeployHelper");
const validate_1 = require("./validate");
const deploymentTool_1 = require("../../deploymentTool");
function functionsByRegion(allFunctions) {
    const partitioned = {};
    for (const fn of allFunctions) {
        partitioned[fn.region] = partitioned[fn.region] || [];
        partitioned[fn.region].push(fn);
    }
    return partitioned;
}
exports.functionsByRegion = functionsByRegion;
function allRegions(spec, existing) {
    return Object.keys(Object.assign(Object.assign({}, spec), existing));
}
exports.allRegions = allRegions;
const matchesId = (hasId) => (test) => {
    return hasId.id === test.id;
};
function calculateRegionalFunctionChanges(want, have, filters) {
    want = want.filter((fn) => functionsDeployHelper_1.functionMatchesAnyGroup(fn, filters));
    have = have.filter((fn) => functionsDeployHelper_1.functionMatchesAnyGroup(fn, filters));
    const functionsToCreate = want.filter((fn) => !have.some(matchesId(fn)));
    const functionsToUpdate = want.filter((fn) => {
        const haveFn = have.find(matchesId(fn));
        if (haveFn) {
            validate_1.checkForInvalidChangeOfTrigger(fn, haveFn);
            fn.environmentVariables = Object.assign(Object.assign({}, haveFn.environmentVariables), fn.environmentVariables);
        }
        return haveFn;
    });
    const functionsToDelete = have
        .filter((fn) => !want.some(matchesId(fn)))
        .filter((fn) => deploymentTool_1.isFirebaseManaged(fn.labels || {}));
    return { functionsToCreate, functionsToUpdate, functionsToDelete };
}
exports.calculateRegionalFunctionChanges = calculateRegionalFunctionChanges;
function createDeploymentPlan(want, have, filters) {
    const deployment = {
        regionalDeployments: {},
        schedulesToUpsert: [],
        schedulesToDelete: [],
        topicsToDelete: [],
    };
    const wantRegionalFunctions = functionsByRegion(want.cloudFunctions);
    const haveRegionalFunctions = functionsByRegion(have.cloudFunctions);
    for (const region of allRegions(wantRegionalFunctions, haveRegionalFunctions)) {
        const want = wantRegionalFunctions[region] || [];
        const have = haveRegionalFunctions[region] || [];
        deployment.regionalDeployments[region] = calculateRegionalFunctionChanges(want, have, filters);
    }
    deployment.schedulesToUpsert = want.schedules.filter((schedule) => functionsDeployHelper_1.functionMatchesAnyGroup(schedule.targetService, filters));
    deployment.schedulesToDelete = have.schedules
        .filter((schedule) => !want.schedules.some(matchesId(schedule)))
        .filter((schedule) => functionsDeployHelper_1.functionMatchesAnyGroup(schedule.targetService, filters));
    deployment.topicsToDelete = have.topics
        .filter((topic) => !want.topics.some(matchesId(topic)))
        .filter((topic) => functionsDeployHelper_1.functionMatchesAnyGroup(topic.targetService, filters));
    return deployment;
}
exports.createDeploymentPlan = createDeploymentPlan;
