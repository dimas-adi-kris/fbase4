"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.schedulerDeploymentHandler = exports.deleteTopicTask = exports.deleteScheduleTask = exports.upsertScheduleTask = exports.runRegionalFunctionDeployment = exports.functionsDeploymentHandler = exports.deleteFunctionTask = exports.updateFunctionTask = exports.createFunctionTask = void 0;
const clc = require("cli-color");
const logger_1 = require("../../logger");
const operation_poller_1 = require("../../operation-poller");
const api_1 = require("../../api");
const runtimes_1 = require("./runtimes");
const pubsub_1 = require("../../gcp/pubsub");
const backend = require("./backend");
const cloudscheduler = require("../../gcp/cloudscheduler");
const deploymentTool = require("../../deploymentTool");
const gcf = require("../../gcp/cloudfunctions");
const gcfV2 = require("../../gcp/cloudfunctionsv2");
const cloudrun = require("../../gcp/run");
const helper = require("./functionsDeployHelper");
const utils = require("../../utils");
const gcfV1PollerOptions = {
    apiOrigin: api_1.functionsOrigin,
    apiVersion: gcf.API_VERSION,
    masterTimeout: 25 * 60 * 1000,
};
const gcfV2PollerOptions = {
    apiOrigin: api_1.functionsV2Origin,
    apiVersion: gcfV2.API_VERSION,
    masterTimeout: 25 * 60 * 1000,
};
const pollerOptionsByVersion = {
    1: gcfV1PollerOptions,
    2: gcfV2PollerOptions,
};
function createFunctionTask(params, fn, sourceToken, onPoll) {
    const fnName = backend.functionName(fn);
    const run = async () => {
        utils.logBullet(clc.bold.cyan("functions: ") +
            "creating " +
            runtimes_1.getHumanFriendlyRuntimeName(fn.runtime) +
            " function " +
            clc.bold(helper.getFunctionLabel(fn)) +
            "...");
        let op;
        if (fn.apiVersion === 1) {
            const apiFunction = gcf.functionFromSpec(fn, params.sourceUrl);
            if (sourceToken) {
                apiFunction.sourceToken = sourceToken;
            }
            op = await gcf.createFunction(apiFunction);
        }
        else {
            const apiFunction = gcfV2.functionFromSpec(fn, params.storageSource);
            op = await gcfV2.createFunction(apiFunction);
        }
        const cloudFunction = await operation_poller_1.pollOperation(Object.assign(Object.assign({}, pollerOptionsByVersion[fn.apiVersion]), { pollerName: `create-${fnName}`, operationResourceName: op.name, onPoll }));
        if (!backend.isEventTrigger(fn.trigger)) {
            try {
                if (fn.apiVersion == 1) {
                    await gcf.setIamPolicy({
                        name: fnName,
                        policy: gcf.DEFAULT_PUBLIC_POLICY,
                    });
                }
                else {
                    const serviceName = cloudFunction.serviceConfig.service;
                    cloudrun.setIamPolicy(serviceName, cloudrun.DEFAULT_PUBLIC_POLICY);
                }
            }
            catch (err) {
                params.errorHandler.record("warning", fnName, "make public", err.message);
            }
        }
    };
    return {
        run,
        fn,
        operationType: "create",
    };
}
exports.createFunctionTask = createFunctionTask;
function updateFunctionTask(params, fn, sourceToken, onPoll) {
    const fnName = backend.functionName(fn);
    const run = async () => {
        utils.logBullet(clc.bold.cyan("functions: ") +
            "updating " +
            runtimes_1.getHumanFriendlyRuntimeName(fn.runtime) +
            " function " +
            clc.bold(helper.getFunctionLabel(fn)) +
            "...");
        let opName;
        if (fn.apiVersion == 1) {
            const apiFunction = gcf.functionFromSpec(fn, params.sourceUrl);
            if (sourceToken) {
                apiFunction.sourceToken = sourceToken;
            }
            opName = (await gcf.updateFunction(apiFunction)).name;
        }
        else {
            const apiFunction = gcfV2.functionFromSpec(fn, params.storageSource);
            opName = (await gcfV2.updateFunction(apiFunction)).name;
        }
        const pollerOptions = Object.assign(Object.assign({}, pollerOptionsByVersion[fn.apiVersion]), { pollerName: `update-${fnName}`, operationResourceName: opName, onPoll });
        await operation_poller_1.pollOperation(pollerOptions);
    };
    return {
        run,
        fn,
        operationType: "update",
    };
}
exports.updateFunctionTask = updateFunctionTask;
function deleteFunctionTask(params, fn) {
    const fnName = backend.functionName(fn);
    const run = async () => {
        utils.logBullet(clc.bold.cyan("functions: ") +
            "deleting function " +
            clc.bold(helper.getFunctionLabel(fnName)) +
            "...");
        let res;
        if (fn.apiVersion == 1) {
            res = await gcf.deleteFunction(fnName);
        }
        else {
            res = await gcfV2.deleteFunction(fnName);
        }
        const pollerOptions = Object.assign(Object.assign({}, pollerOptionsByVersion[fn.apiVersion]), { pollerName: `delete-${fnName}`, operationResourceName: res.name });
        await operation_poller_1.pollOperation(pollerOptions);
    };
    return {
        run,
        fn,
        operationType: "delete",
    };
}
exports.deleteFunctionTask = deleteFunctionTask;
function functionsDeploymentHandler(timer, errorHandler) {
    return async (task) => {
        var _a, _b, _c, _d;
        let result;
        const fnName = backend.functionName(task.fn);
        try {
            timer.startTimer(fnName, task.operationType);
            result = await task.run();
            helper.printSuccess(task.fn, task.operationType);
        }
        catch (err) {
            if (((_c = (_b = (_a = err.original) === null || _a === void 0 ? void 0 : _a.context) === null || _b === void 0 ? void 0 : _b.response) === null || _c === void 0 ? void 0 : _c.statusCode) === 429) {
                throw err;
            }
            errorHandler.record("error", fnName, task.operationType, ((_d = err.original) === null || _d === void 0 ? void 0 : _d.message) || "");
        }
        timer.endTimer(fnName);
        return result;
    };
}
exports.functionsDeploymentHandler = functionsDeploymentHandler;
async function runRegionalFunctionDeployment(params, region, regionalDeployment, queue) {
    let resolveToken;
    const getRealToken = new Promise((resolve) => (resolveToken = resolve));
    let firstToken = true;
    const getToken = () => {
        if (firstToken) {
            firstToken = false;
            return Promise.resolve(undefined);
        }
        return getRealToken;
    };
    const onPollFn = (op) => {
        var _a, _b;
        if (((_a = op.metadata) === null || _a === void 0 ? void 0 : _a.sourceToken) || op.done) {
            logger_1.logger.debug(`Got sourceToken ${op.metadata.sourceToken} for region ${region}`);
            resolveToken((_b = op.metadata) === null || _b === void 0 ? void 0 : _b.sourceToken);
        }
    };
    const deploy = async (functionSpec, createTask) => {
        functionSpec.labels = Object.assign(Object.assign({}, (functionSpec.labels || {})), deploymentTool.labels());
        let task;
        if (functionSpec.apiVersion == 2) {
            task = createTask(params, functionSpec, undefined, () => undefined);
        }
        else {
            const sourceToken = await getToken();
            task = createTask(params, functionSpec, sourceToken, onPollFn);
        }
        return queue.run(task);
    };
    const deploys = [];
    deploys.push(...regionalDeployment.functionsToCreate.map((fn) => deploy(fn, createFunctionTask)));
    deploys.push(...regionalDeployment.functionsToUpdate.map((fn) => deploy(fn, updateFunctionTask)));
    await Promise.all(deploys);
    const deletes = regionalDeployment.functionsToDelete.map(async (fn) => {
        const task = deleteFunctionTask(params, fn);
        await queue.run(task);
    });
    await Promise.all(deletes);
}
exports.runRegionalFunctionDeployment = runRegionalFunctionDeployment;
function upsertScheduleTask(params, schedule, appEngineLocation) {
    const run = async () => {
        const job = cloudscheduler.jobFromSpec(schedule, appEngineLocation);
        await cloudscheduler.createOrReplaceJob(job);
    };
    return {
        run,
        fn: schedule.targetService,
        operationType: "upsert schedule",
    };
}
exports.upsertScheduleTask = upsertScheduleTask;
function deleteScheduleTask(params, schedule, appEngineLocation) {
    const run = async () => {
        const jobName = backend.scheduleName(schedule, appEngineLocation);
        await cloudscheduler.deleteJob(jobName);
    };
    return {
        run,
        fn: schedule.targetService,
        operationType: "delete schedule",
    };
}
exports.deleteScheduleTask = deleteScheduleTask;
function deleteTopicTask(params, topic) {
    const run = async () => {
        const topicName = backend.topicName(topic);
        await pubsub_1.deleteTopic(topicName);
    };
    return {
        run,
        fn: topic.targetService,
        operationType: "delete topic",
    };
}
exports.deleteTopicTask = deleteTopicTask;
exports.schedulerDeploymentHandler = (errorHandler) => async (task) => {
    try {
        const result = await task.run();
        helper.printSuccess(task.fn, task.operationType);
        return result;
    }
    catch (err) {
        if (err.status === 429) {
            throw err;
        }
        else if (err.status !== 404) {
            errorHandler.record("error", backend.functionName(task.fn), task.operationType, err.message || "");
        }
    }
};
