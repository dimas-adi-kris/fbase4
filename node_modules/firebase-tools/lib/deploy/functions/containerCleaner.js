"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DockerHelper = exports.ContainerRegistryCleaner = exports.cleanupBuildImages = void 0;
const clc = require("cli-color");
const api_1 = require("../../api");
const logger_1 = require("../../logger");
const docker = require("../../gcp/docker");
const backend = require("./backend");
const utils = require("../../utils");
const SUBDOMAIN_MAPPING = {
    "us-west2": "us",
    "us-west3": "us",
    "us-west4": "us",
    "us-central1": "us",
    "us-central2": "us",
    "us-east1": "us",
    "us-east4": "us",
    "northamerica-northeast1": "us",
    "southamerica-east1": "us",
    "europe-west1": "eu",
    "europe-west2": "eu",
    "europe-west3": "eu",
    "europe-west5": "eu",
    "europe-west6": "eu",
    "europe-central2": "eu",
    "asia-east1": "asia",
    "asia-east2": "asia",
    "asia-northeast1": "asia",
    "asia-northeast2": "asia",
    "asia-northeast3": "asia",
    "asia-south1": "asia",
    "asia-southeast2": "asia",
    "australia-southeast1": "asia",
};
async function cleanupBuildImages(functions) {
    utils.logBullet(clc.bold.cyan("functions: ") + "cleaning up build files...");
    const gcrCleaner = new ContainerRegistryCleaner();
    const failedDomains = new Set();
    await Promise.all(functions.map((func) => (async () => {
        try {
            await gcrCleaner.cleanupFunction(func);
        }
        catch (err) {
            const path = `${func.project}/${SUBDOMAIN_MAPPING[func.region]}/gcf`;
            failedDomains.add(`https://console.cloud.google.com/gcr/images/${path}`);
        }
    })()));
    if (failedDomains.size) {
        let message = "Unhandled error cleaning up build images. This could result in a small monthly bill if not corrected. ";
        message +=
            "You can attempt to delete these images by redeploying or you can delete them manually at";
        if (failedDomains.size == 1) {
            message += " " + failedDomains.values().next().value;
        }
        else {
            message += [...failedDomains].map((domain) => "\n\t" + domain).join("");
        }
        utils.logLabeledWarning("functions", message);
    }
}
exports.cleanupBuildImages = cleanupBuildImages;
class ContainerRegistryCleaner {
    constructor() {
        this.helpers = {};
    }
    helper(location) {
        const subdomain = SUBDOMAIN_MAPPING[location] || "us";
        if (!this.helpers[subdomain]) {
            const origin = `https://${subdomain}.${api_1.containerRegistryDomain}`;
            this.helpers[subdomain] = new DockerHelper(origin);
        }
        return this.helpers[subdomain];
    }
    async cleanupFunction(func) {
        const helper = this.helper(func.region);
        const uuids = (await helper.ls(`${func.project}/gcf/${func.region}`)).children;
        const uuidTags = {};
        const loadUuidTags = [];
        for (const uuid of uuids) {
            loadUuidTags.push((async () => {
                const path = `${func.project}/gcf/${func.region}/${uuid}`;
                const tags = (await helper.ls(path)).tags;
                uuidTags[path] = tags;
            })());
        }
        await Promise.all(loadUuidTags);
        const extractFunction = /^(.*)_version-\d+$/;
        const entry = Object.entries(uuidTags).find(([, tags]) => {
            return tags.find((tag) => { var _a; return ((_a = extractFunction.exec(tag)) === null || _a === void 0 ? void 0 : _a[1]) === func.id; });
        });
        if (!entry) {
            logger_1.logger.debug("Could not find image for function", backend.functionName(func));
            return;
        }
        await helper.rm(entry[0]);
    }
}
exports.ContainerRegistryCleaner = ContainerRegistryCleaner;
class DockerHelper {
    constructor(origin) {
        this.cache = {};
        this.client = new docker.Client(origin);
    }
    async ls(path) {
        if (!this.cache[path]) {
            const raw = await this.client.listTags(path);
            this.cache[path] = {
                tags: raw.tags,
                digests: Object.keys(raw.manifest),
                children: raw.child,
            };
        }
        return this.cache[path];
    }
    async rm(path) {
        let toThrowLater = undefined;
        const stat = await this.ls(path);
        const recursive = stat.children.map((child) => (async () => {
            try {
                await this.rm(`${path}/${child}`);
                stat.children.splice(stat.children.indexOf(child), 1);
            }
            catch (err) {
                toThrowLater = err;
            }
        })());
        const deleteTags = stat.tags.map((tag) => (async () => {
            try {
                await this.client.deleteTag(path, tag);
                stat.tags.splice(stat.tags.indexOf(tag), 1);
            }
            catch (err) {
                logger_1.logger.debug("Got error trying to remove docker tag:", err);
                toThrowLater = err;
            }
        })());
        await Promise.all(deleteTags);
        const deleteImages = stat.digests.map((digest) => (async () => {
            try {
                await this.client.deleteImage(path, digest);
                stat.digests.splice(stat.digests.indexOf(digest), 1);
            }
            catch (err) {
                logger_1.logger.debug("Got error trying to remove docker image:", err);
                toThrowLater = err;
            }
        })());
        await Promise.all(deleteImages);
        await Promise.all(recursive);
        if (toThrowLater) {
            throw toThrowLater;
        }
    }
}
exports.DockerHelper = DockerHelper;
